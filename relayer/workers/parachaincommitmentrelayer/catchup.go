package parachaincommitmentrelayer

import (
	"context"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/sirupsen/logrus"
	rpcOffchain "github.com/snowfork/go-substrate-rpc-client/v3/rpc/offchain"
	"github.com/snowfork/go-substrate-rpc-client/v3/types"
	"github.com/snowfork/polkadot-ethereum/relayer/chain/parachain"
	"github.com/snowfork/polkadot-ethereum/relayer/contracts/basic"
	"github.com/snowfork/polkadot-ethereum/relayer/contracts/incentivized"
	"github.com/snowfork/polkadot-ethereum/relayer/substrate"
	chainTypes "github.com/snowfork/polkadot-ethereum/relayer/substrate"
)

// Catches up by searching for and relaying all missed commitments before the given block
func (li *BeefyListener) catchupMissedCommitments(ctx context.Context, latestParaBlock uint64, latestParaHash types.Hash) error {
	basicContract, err := basic.NewBasicInboundChannel(common.HexToAddress(
		li.ethereumConfig.Channels.Basic.Inbound),
		li.ethereumConn.GetClient(),
	)
	if err != nil {
		return err
	}

	incentivizedContract, err := incentivized.NewIncentivizedInboundChannel(common.HexToAddress(
		li.ethereumConfig.Channels.Incentivized.Inbound),
		li.ethereumConn.GetClient(),
	)
	if err != nil {
		return err
	}

	options := bind.CallOpts{
		Pending: true,
		Context: ctx,
	}

	ethBasicNonce, err := basicContract.Nonce(&options)
	if err != nil {
		return err
	}
	li.log.WithFields(logrus.Fields{
		"nonce": ethBasicNonce,
	}).Info("Checked latest nonce delivered to ethereum basic channel")

	ethIncentivizedNonce, err := incentivizedContract.Nonce(&options)
	if err != nil {
		return err
	}
	li.log.WithFields(logrus.Fields{
		"nonce": ethIncentivizedNonce,
	}).Info("Checked latest nonce delivered to ethereum incentivized channel")

	paraBasicNonceKey, err := types.CreateStorageKey(li.parachainConnection.GetMetadata(), "BasicOutboundModule", "Nonce", nil, nil)
	if err != nil {
		li.log.Error(err)
		return err
	}
	var paraBasicNonce types.U64
	ok, err := li.parachainConnection.GetAPI().RPC.State.GetStorage(paraBasicNonceKey, &paraBasicNonce, latestParaHash)
	if err != nil {
		li.log.Error(err)
		return err
	}
	if !ok {
		paraBasicNonce = 0
	}
	li.log.WithFields(logrus.Fields{
		"nonce": uint64(paraBasicNonce),
	}).Info("Checked latest nonce generated by parachain basic channel")

	paraIncentivizedNonceKey, err := types.CreateStorageKey(li.parachainConnection.GetMetadata(), "IncentivizedOutboundModule", "Nonce", nil, nil)
	if err != nil {
		li.log.Error(err)
		return err
	}
	var paraIncentivizedNonce types.U64
	ok, err = li.parachainConnection.GetAPI().RPC.State.GetStorage(paraIncentivizedNonceKey, &paraIncentivizedNonce, latestParaHash)
	if err != nil {
		li.log.Error(err)
		return err
	}
	if !ok {
		paraBasicNonce = 0
	}
	li.log.WithFields(logrus.Fields{
		"nonce": uint64(paraIncentivizedNonce),
	}).Info("Checked latest nonce generated by parachain incentivized channel")

	if ethBasicNonce == uint64(paraBasicNonce) && ethIncentivizedNonce == uint64(paraIncentivizedNonce) {
		return nil
	}

	err = li.searchForLostCommitments(latestParaBlock, ethBasicNonce, ethIncentivizedNonce)
	if err != nil {
		return err
	}

	li.log.Info("Stopped searching for lost commitments")

	return nil
}

func (li *BeefyListener) searchForLostCommitments(lastParaBlockNumber uint64, basicNonceToFind uint64, incentivizedNonceToFind uint64) error {
	li.log.WithFields(logrus.Fields{
		"basicNonce":        basicNonceToFind,
		"incentivizedNonce": incentivizedNonceToFind,
		"latestblockNumber": lastParaBlockNumber,
	}).Debug("Searching backwards from latest block on parachain to find block with nonce")
	basicId := substrate.ChannelID{IsBasic: true}
	incentivizedId := substrate.ChannelID{IsIncentivized: true}

	currentBlockNumber := lastParaBlockNumber + 1
	basicNonceFound := false
	incentivizedNonceFound := false
	var digestItems []*chainTypes.AuxiliaryDigestItem
	for (basicNonceFound == false || incentivizedNonceFound == false) && currentBlockNumber != 0 {
		currentBlockNumber--
		li.log.WithFields(logrus.Fields{
			"blockNumber": currentBlockNumber,
		}).Debug("Checking header...")

		blockHash, err := li.parachainConnection.GetAPI().RPC.Chain.GetBlockHash(currentBlockNumber)
		if err != nil {
			li.log.WithFields(logrus.Fields{
				"blockNumber": currentBlockNumber,
			}).WithError(err).Error("Failed to fetch blockhash")
			return err
		}

		header, err := li.parachainConnection.GetAPI().RPC.Chain.GetHeader(blockHash)
		if err != nil {
			li.log.WithError(err).Error("Failed to fetch header")
			return err
		}

		digestItems, err := li.getAuxiliaryDigestItems(header.Digest)
		if err != nil {
			return err
		}

		for _, digestItem := range digestItems {
			if digestItem.IsCommitment {
				channelID := digestItem.AsCommitment.ChannelID
				if channelID == basicId && !basicNonceFound {
					isRelayed, err := li.checkBasicMessageNonces(&digestItem, basicNonceToFind)
					if err != nil {
						return err
					}
					if isRelayed {
						basicNonceFound = true
					} else {
						digestItems = append(digestItems, digestItem)
					}
				}
				if channelID == incentivizedId && !incentivizedNonceFound {
					isRelayed, err := li.checkIncentivizedMessageNonces(&digestItem, incentivizedNonceToFind)
					if err != nil {
						return err
					}
					if isRelayed {
						incentivizedNonceFound = true
					} else {
						digestItems = append(digestItems, digestItem)
					}
				}
			}
		}

	}

	// Reverse items
	for i, j := 0, len(digestItems)-1; i < j; i, j = i+1, j-1 {
		digestItems[i], digestItems[j] = digestItems[j], digestItems[i]
	}

	// for _, digestItem := range digestItems {
	// 	err := li.processCommitment(digestItem.AsCommitment.ChannelID, digestItem.AsCommitment.Hash)
	// 	if err != nil {
	// 		return err
	// 	}
	// }

	return nil
}

func (li *BeefyListener) checkBasicMessageNonces(
	digestItem *chainTypes.AuxiliaryDigestItem,
	nonceToFind uint64,
) (bool, error) {
	messages, err := li.getBasicMessages(digestItem.AsCommitment.Hash)
	if err != nil {
		return false, err
	}

	for _, message := range messages {
		if message.Nonce <= nonceToFind {
			return true, nil
		}
	}
	return false, nil
}

func (li *BeefyListener) checkIncentivizedMessageNonces(
	digestItem *chainTypes.AuxiliaryDigestItem,
	nonceToFind uint64,
) (bool, error) {
	messages, err := li.getIncentivizedMessages(digestItem.AsCommitment.Hash)
	if err != nil {
		return false, err
	}

	for _, message := range messages {
		if message.Nonce <= nonceToFind {
			return true, nil
		}
	}
	return false, nil
}

func (li *BeefyListener) getBasicMessages(commitment types.H256) ([]chainTypes.BasicOutboundChannelMessage, error) {
	storageKey, err := parachain.MakeStorageKey(substrate.ChannelID{IsBasic: true}, commitment)
	if err != nil {
		return nil, err
	}

	data, err := li.parachainConnection.GetAPI().RPC.Offchain.LocalStorageGet(rpcOffchain.Persistent, storageKey)
	if err != nil {
		li.log.WithError(err).Error("Failed to read commitment from offchain storage")
		return nil, err
	}

	if data != nil {
		li.log.WithFields(logrus.Fields{
			"commitmentSizeBytes": len(*data),
		}).Debug("Retrieved commitment from offchain storage")
	} else {
		li.log.WithError(err).Error("Commitment not found in offchain storage")
		return nil, err
	}

	var messages []chainTypes.BasicOutboundChannelMessage

	err = types.DecodeFromBytes(*data, &messages)
	if err != nil {
		li.log.WithError(err).Error("Failed to decode commitment messages")
		return nil, err
	}

	return messages, nil
}

func (li *BeefyListener) getIncentivizedMessages(commitment types.H256) ([]chainTypes.IncentivizedOutboundChannelMessage, error) {
	storageKey, err := parachain.MakeStorageKey(substrate.ChannelID{IsIncentivized: true}, commitment)
	if err != nil {
		return nil, err
	}

	data, err := li.parachainConnection.GetAPI().RPC.Offchain.LocalStorageGet(rpcOffchain.Persistent, storageKey)
	if err != nil {
		li.log.WithError(err).Error("Failed to read commitment from offchain storage")
		return nil, err
	}

	if data != nil {
		li.log.WithFields(logrus.Fields{
			"commitmentSizeBytes": len(*data),
		}).Debug("Retrieved commitment from offchain storage")
	} else {
		li.log.WithError(err).Error("Commitment not found in offchain storage")
		return nil, err
	}

	var messages []chainTypes.IncentivizedOutboundChannelMessage

	err = types.DecodeFromBytes(*data, &messages)
	if err != nil {
		li.log.WithError(err).Error("Failed to decode commitment messages")
		return nil, err
	}

	return messages, nil
}

// Fetch the latest block of our parachain that has been finalized on the relay chain
func (li *BeefyListener) fetchLatestBlockAndHash() (uint64, types.Hash, error) {
	blockHash, err := li.relaychainConn.GetAPI().RPC.Chain.GetBlockHashLatest()
	if err != nil {
		li.log.WithError(err).Error("Failed to get latest relay chain block hash")
		return 0, types.Hash{}, err
	}
	li.log.WithField("blockHash", blockHash.Hex()).Info("Got latest relaychain blockhash")

	_, ourParaHead := li.relaychainConn.GetAllParaheadsWithOwn(blockHash, OUR_PARACHAIN_ID)
	latestParaBlockNumber := uint64(ourParaHead.Number)
	ourParaHeadHash, err := li.parachainConnection.Api().RPC.Chain.GetBlockHash(latestParaBlockNumber)
	if err != nil {
		li.log.WithError(err).Error("Failed to get parachain block hash")
		return 0, types.Hash{}, err
	}

	return uint64(latestParaBlockNumber), ourParaHeadHash, nil
}
